# 2020-10-27 창의 공학 설계 1 (방사율)
### 창의공학설계에 따라 만들고자 하는 것과 관련된 정보를 정리해 봤습니다.
### (이 문서는 날짜별로 내용이 추가될 예정입니다.)


만들게 될 것: 비접촉 적외선 온도계


## 방사율이란? 
직역하면 '물질에서 방사되는 에너지의 비율'이라고 말할 수 있습니다.


즉, 100만큼의 에너지를 가진 물질이 에너지를 얼마만큼 방사하는지에 대한 비율입니다.


예를 들어 100℃의 물체가 방사하는 적외선을 온도계로 측정했을 때 30℃로 나타냅니다.


이는 물체가 30%만큼의 적외선을 방사한다는 의미입니다.


## 온도 보정
그래서 방사율만을 측정하는 온도계에서 실제 온도를 측정하려면 온도 보정을 해야합니다.


만약 위와 같은 물질이 있다면 70%만큼의 온도를 보정해야 실제 온도를 유추할 수 있습니다.



## 그 외 다른 것들
사실 깊게 설명하려면 더 많은 내용을 설명해야해서 간단하게만 적었는데요.


저도 제가 이해한 내용을 정리한 것이라 얼마든지 오개념이 있을 수 있습니다.


혹시나 오개념이나 그 외 다른 사항이 있다면 프로필에 적힌 메일로 연락주시면 감사하겠습니다.


# 2020-11-13 창의 공학 설계2 (라인트레이서)
### 원래는 온도계를 만들 생각이였는데 계획을 변경했어요.
### 제가 만들 라인트레이서에 대해 설명하는거라 조금 다른 부분이 있을 수 있습니다.


## 라인트레이서란?
간단하게 맵에 그려진 선을 따라 움직이는 로봇을 말해요.


보통은 흰색 바탕에 검은 선을 쓰기 때문에 빛을 얼마나 반사하고 흡수하는 지에 따라 선을 구분할 수 있어요.

## 라인트레이서 생김새
저는 레고 마인드스톰 EV3 로봇을 사용했어요.


![EV3](https://github.com/Banglazzo/Today_I_Learned/blob/master/%EC%B0%BD%EC%9D%98%EA%B3%B5%ED%95%99%EC%84%A4%EA%B3%84/img/EV3%20%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B9%99%20%EB%B2%A0%EC%9D%B4%EC%8A%A4(%EB%9D%BC%EC%9D%B8%ED%8A%B8%EB%A0%88%EC%9D%B4%EC%84%9C).jpg)


(센서 연결 전에 찍은 사진이고 문제 될만한 것은 다 블러+모자이크 처리했어요)


센서는 컬러센서(반사광 모드)로 두개를 장착했습니다.

## 라인트레이서 원리
제가 구현할 라인트레이서의 원리를 간단하게 설명해보겠습니다.


우선 경계 값이라는 걸 계산해줄거에요.


경계 값이란 흰색과 검정색을 판단하는 기준으로 쓰일 값을 말해요.


예를 들어 흰색을 100, 검정색을 0으로 본다면 대략 45 ~ 50 정도로 경계 값을 설정합니다.


이 경계 값보다 크면 흰색, 작으면 검정색으로 인식하도록 만들어서


로봇이 검은 선을 따라가도록 하는 원리입니다.



## 정렬 알고리즘을 이용한 라인 트레이싱
이제 제가 만들 라인트레이싱에 대해 자세히 설명드리겠습니다.


우선 컬러 센서의 값을 1/1000초 단위로 각각 10번씩 측정하여 배열에 저장합니다.


이후에 정렬 알고리즘을 통해 값을 오름차순으로 정렬합니다.


가장 큰 값 2개와 가장 작은 값 2개를 제거합니다. 


나머지 6개 값의 평균을 구하여 그 값을 경계 값으로 사용합니다.


이 과정을 실시간으로 반복해주면 됩니다.


앞에서 말씀 드렸던 경계 값인 45로 설정하면 


여러 환경 변수에 따라 정확도가 크게 달라집니다.


그러나 정렬 알고리즘을 이용해 실시간으로 경계 값을 계산해주면 


빛의 세기나 맵의 크기 등 여러 환경에도 거의 성능 차이가 나지 않는 라인트레이서를 만들 수 있습니다.


혹시나 오개념이 있다면 알려주세요.


# 2020-11-16 창의 공학 설계3 (퀵 정렬 알고리즘)
### 퀵 정렬 알고리즘의 기본 개념을 준비했습니다. 코드는 추후에 창의 공학 설계 폴더 안에 넣어놓도록 하겠습니다.

## 퀵 정렬 알고리즘이란?
이름처럼 정렬 알고리즘 중 가장 빠른 알고리즘입니다. 평균적으로 O(n log n)의 시간 복잡도를 갖습니다.


값을 비교하는 방식으로 정렬하는 비교 정렬이며, 피봇이라는 기준 값을 두고 비교 연산을 수행합니다. 


여기서 퀵 정렬 알고리즘의 단점을 알 수 있는데, 피봇 값에 따라 시간 복잡도가 O(n²)으로 나타나기도 합니다.


## 그림으로 보는 퀵 정렬 알고리즘 
![quick_sort1](https://github.com/Banglazzo/Today_I_Learned/blob/master/%EC%B0%BD%EC%9D%98%EA%B3%B5%ED%95%99%EC%84%A4%EA%B3%84/img/%ED%80%B5%20%EC%A0%95%EB%A0%AC1.PNG)


arr[0]을 피봇 값으로 두었을 때 i와 j값입니다. 


i는 피봇을 제외한 처음 원소부터 피봇 보다 큰 값을 가리킵니다.


j는 피봇을 제외한 처음 원소부터 피봇 보다 작은 값을 가리킵니다.


![quick_sort2](https://github.com/Banglazzo/Today_I_Learned/blob/master/%EC%B0%BD%EC%9D%98%EA%B3%B5%ED%95%99%EC%84%A4%EA%B3%84/img/%ED%80%B5%20%EC%A0%95%EB%A0%AC2.PNG)


i와 j가 가리키는 값을 교환합니다. 


이 과정을 반복하다가 값을 교환했을 때 i가 j보다 커질 경우 피봇과 j의 위치를 바꿉니다.


![quick_sort3](https://github.com/Banglazzo/Today_I_Learned/blob/master/%EC%B0%BD%EC%9D%98%EA%B3%B5%ED%95%99%EC%84%A4%EA%B3%84/img/%ED%80%B5%20%EC%A0%95%EB%A0%AC3.PNG)


![quick_sort4](https://github.com/Banglazzo/Today_I_Learned/blob/master/%EC%B0%BD%EC%9D%98%EA%B3%B5%ED%95%99%EC%84%A4%EA%B3%84/img/%ED%80%B5%20%EC%A0%95%EB%A0%AC4.PNG)


이렇게 한 바퀴를 돌게 되면 피봇 값은 제 위치에 존재하게 됩니다.


그리고 피봇 값을 기준으로 왼쪽엔 피봇 보다 작은 값이, 오른쪽에는 피봇 보다 큰 값이 존재하게 됩니다.



![quick_sort5](https://github.com/Banglazzo/Today_I_Learned/blob/master/%EC%B0%BD%EC%9D%98%EA%B3%B5%ED%95%99%EC%84%A4%EA%B3%84/img/%ED%80%B5%20%EC%A0%95%EB%A0%AC5.PNG)


(사진이 조금 잘렸네요. 죄송합니다.)


이제 왼쪽과 오른쪽으로 나뉘어 각 리스트가 0이나 1이 될 때 까지 퀵 정렬을 실행합니다.


![quick_sort6](https://github.com/Banglazzo/Today_I_Learned/blob/master/%EC%B0%BD%EC%9D%98%EA%B3%B5%ED%95%99%EC%84%A4%EA%B3%84/img/%ED%80%B5%20%EC%A0%95%EB%A0%AC6.PNG)


![quick_sort7](https://github.com/Banglazzo/Today_I_Learned/blob/master/%EC%B0%BD%EC%9D%98%EA%B3%B5%ED%95%99%EC%84%A4%EA%B3%84/img/%ED%80%B5%20%EC%A0%95%EB%A0%AC7.PNG)